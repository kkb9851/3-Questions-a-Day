이 문제는 얼핏 보면 복잡해 보일 수 있지만, **이동 규칙**과 **건전지 사용 조건**을 잘 이해하면 놀랍게도 \*\*이진수(Binary)\*\*와 밀접한 관계가 있는 문제입니다.

---

## 🧠 문제 핵심 요약

* 현재 위치: `0`
* 목표 위치: `N`
* 이동 방법:

  1. **앞으로 K칸 점프** → 건전지 소모 **K**
  2. **순간이동 (현재까지 온 거리 × 2)** → **건전지 소모 없음**
* **목표**: N까지 도달하는 데 **건전지 사용량 최소화**

---

## ✅ 가장 중요한 아이디어

**순간이동은 공짜**, 점프는 건전지를 사용하므로,
→ **순간이동은 최대한 많이, 점프는 최소한으로** 해야 합니다.

---

## 🔍 쉬운 예시: N = 5

**역방향으로 생각해 봅시다.**

### 👉 역으로 N에서 0으로 돌아가기

현재 위치가 5라고 하면:

* 5는 짝수 ❌ → 순간이동 불가능
* 1칸 점프했구나 → 건전지 +1 → 4로 돌아감
  ↘ 4는 짝수 → 순간이동 가능! → 2로 → 1로 → 0 도달!

**점프는 1번, 1번 → 총 2번 필요**
→ 건전지 소모량: **2**

---

## 🧩 핵심 패턴: **2로 나눌 수 있을 때는 순간이동, 홀수면 점프**

이걸 코드로 보면 다음과 같습니다:

```python
while N > 0:
    if N % 2 == 0:  # 짝수: 순간이동 (건전지 소모 없음)
        N //= 2
    else:           # 홀수: 점프 (건전지 +1)
        N -= 1
        battery += 1
```

---

## 🔢 정리: **N을 이진수로 바꿨을 때 1의 개수가 곧 최소 건전지 사용량**

예:

* N = 5 → `101` → 1의 개수 = 2 → 정답: 2
* N = 6 → `110` → 1의 개수 = 2 → 정답: 2
* N = 7 → `111` → 1의 개수 = 3 → 정답: 3

---

## ✅ 완전한 해답 코드

```python
def solution(n):
    return bin(n).count('1')
```

---

## 🔧 요약

* 순간이동은 2배 → **2로 나눌 수 있을 때 순간이동**
* 홀수일 때만 점프 필요 → **건전지 소모**
* 결국: **N을 이진수로 변환 → '1'의 개수 = 최소 점프 수 = 최소 건전지 사용량**

이런 식의 문제는 **그리디(탐욕법)** + **이진수 사고**를 결합한 전형적인 알고리즘 유형입니다.
