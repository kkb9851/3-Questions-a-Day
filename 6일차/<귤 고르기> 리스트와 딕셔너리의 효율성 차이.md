두 코드의 핵심 목적은 동일합니다:
**`tangerine` 리스트에서 최소한의 종류로 `k`개 이상의 귤을 선택하는 것**입니다.

하지만 **1번째 코드**는 비효율적인 방식 때문에 **시간 초과**가 발생하고,
\*\*2번째 코드(정답 코드)\*\*는 **딕셔너리**를 사용해 효율성을 크게 향상시켰습니다.
차이점을 구체적으로 분석해드리겠습니다.

---

### ✅ 1번째 코드: 비효율적인 방식

```python
for i in t:
    cnt.append(tangerine.count(i))
```

* 이 구문이 **문제의 핵심 비효율성**입니다.
* `tangerine.count(i)`는 리스트 전체를 순회하며 `i`의 개수를 세는데,
  이게 `set(tangerine)`의 원소 개수만큼 반복됩니다.
* 만약 `tangerine` 길이가 `n`, 고유 값 개수가 `m`이면, 시간 복잡도는 \*\*O(m \* n)\*\*입니다.
* `m`이 거의 `n`과 비슷하다면, 사실상 \*\*O(n²)\*\*입니다 → 대량 데이터에서 **시간 초과** 발생.

---

### ✅ 2번째 코드: 효율적인 딕셔너리 활용

```python
for i in tangerine:
    dic[i] = dic.get(i, 0) + 1
```

* 딕셔너리는 평균적으로 **O(1)** 시간에 삽입/조회가 가능합니다.
* 따라서 전체 반복문은 **O(n)** 시간에 실행됩니다.
* 이후 정렬은 \*\*O(m log m)\*\*입니다 (`m`은 고유한 종류의 수).
* 전체 시간 복잡도는 \*\*O(n + m log m)\*\*로, 훨씬 효율적입니다.

---

### 🔍 정리

| 항목          | 1번째 코드                   | 2번째 코드 (정답)     |
| ----------- | ------------------------ | --------------- |
| 주요 자료구조     | 리스트, set                 | 딕셔너리 (hash map) |
| 빈도수 계산 방식   | `.count()` 다회 사용 → O(n²) | 딕셔너리 누적 → O(n)  |
| 전체 시간 복잡도   | O(n²) 수준                 | O(n + m log m)  |
| 대량 데이터에서 성능 | 매우 느림 (시간 초과 가능)         | 빠름 (효율적 처리 가능)  |

---
